<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>A-Frame + Three.js ç¯ç½‘å¯è§†åŒ–</title>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.0/dist/aframe-environment-component.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: Arial, sans-serif;
        overflow: hidden;
      }

      #ui {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 10px;
        z-index: 1000;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        max-width: 300px;
      }

      h1 {
        color: #333;
        margin-bottom: 20px;
        font-size: 24px;
      }

      .control-group {
        margin-bottom: 15px;
      }

      label {
        display: block;
        margin-bottom: 5px;
        color: #666;
      }

      select,
      button {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }

      button {
        background: #4285f4;
        color: white;
        border: none;
        cursor: pointer;
        transition: background 0.3s;
      }

      button:hover {
        background: #3367d6;
      }

      .stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
        margin-top: 20px;
      }

      .stat {
        background: #f5f5f5;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
      }

      .stat-value {
        font-size: 18px;
        font-weight: bold;
        color: #4285f4;
      }

      .stat-label {
        font-size: 12px;
        color: #666;
      }
    </style>
  </head>
  <body>
    <!-- A-Frame åœºæ™¯ -->
    <a-scene
      cursor="rayOrigin: mouse"
      raycaster="objects: .clickable"
      renderer="colorManagement: true;"
      vr-mode-ui="enabled: false"
      embedded
    >
      <!-- ç›¸æœº -->
      <a-entity
        id="camera"
        camera="fov: 80; zoom: 1;"
        look-controls
        wasd-controls="acceleration: 100"
      >
        <a-entity
          cursor="fuse: false; fuseTimeout: 500"
          position="0 0 -1"
          geometry="primitive: ring; radiusInner: 0.02; radiusOuter: 0.03"
          material="color: white; shader: flat"
          raycaster="objects: .clickable"
        ></a-entity>
      </a-entity>

      <!-- è‡ªå®šä¹‰ç¯ç½‘ç»„ä»¶ -->
      <a-entity
        id="network-container"
        position="0 1.5 -4"
        ring-network="nodeCount: 8; radius: 3"
      ></a-entity>

      <!-- ç¯å¢ƒ -->
      <a-entity environment="preset: forest; dressingAmount: 1000"></a-entity>

      <!-- ç¯å…‰ -->
      <a-entity light="type: ambient; color: #BBB; intensity: 0.5"></a-entity>
      <a-entity light="type: directional; color: #FFF; intensity: 0.8" position="-5 5 5"></a-entity>

      <!-- åœ°é¢ -->
      <a-plane
        position="0 0 0"
        rotation="-90 0 0"
        width="100"
        height="100"
        color="#e0e0e0"
        shadow
      ></a-plane>

      <!-- å¤©ç©º -->
      <a-sky color="#87CEEB"></a-sky>
    </a-scene>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div id="ui">
      <h1>ğŸŒ ç¯ç½‘å¯è§†åŒ–</h1>

      <div class="control-group">
        <label>èŠ‚ç‚¹æ•°é‡</label>
        <select id="nodeCount">
          <option value="6">6 ä¸ªèŠ‚ç‚¹</option>
          <option value="8" selected>8 ä¸ªèŠ‚ç‚¹</option>
          <option value="10">10 ä¸ªèŠ‚ç‚¹</option>
          <option value="12">12 ä¸ªèŠ‚ç‚¹</option>
        </select>
      </div>

      <div class="control-group">
        <label>æ‹“æ‰‘ç»“æ„</label>
        <select id="topology">
          <option value="ring">å•ç¯</option>
          <option value="dual-ring">åŒç¯</option>
          <option value="mesh">ç½‘çŠ¶</option>
        </select>
      </div>

      <div class="control-group">
        <label>æ•°æ®æµåŠ¨</label>
        <select id="dataFlow">
          <option value="clockwise">é¡ºæ—¶é’ˆ</option>
          <option value="counterclockwise" selected>é€†æ—¶é’ˆ</option>
        </select>
      </div>

      <button id="refresh">åˆ·æ–°ç½‘ç»œ</button>
      <button id="simulateFault">æ¨¡æ‹Ÿæ•…éšœ</button>
      <button id="enterVR" style="background: #673ab7">è¿›å…¥ VR æ¨¡å¼</button>

      <div class="stats">
        <div class="stat">
          <div class="stat-value" id="onlineNodes">8/8</div>
          <div class="stat-label">åœ¨çº¿èŠ‚ç‚¹</div>
        </div>
        <div class="stat">
          <div class="stat-value" id="linkStatus">100%</div>
          <div class="stat-label">é“¾è·¯çŠ¶æ€</div>
        </div>
      </div>
    </div>

    <script>
      // ç¯ç½‘ç»„ä»¶
      AFRAME.registerComponent('ring-network', {
        schema: {
          nodeCount: {type: 'number', default: 8},
          radius: {type: 'number', default: 3},
          topology: {type: 'string', default: 'ring'},
          dataFlow: {type: 'string', default: 'counterclockwise'}
        },

        init: function () {
          // è·å– Three.js å¯¹è±¡
          this.object3D = this.el.object3D
          this.scene = this.el.sceneEl.object3D

          // ç½‘ç»œå…ƒç´ 
          this.nodes = []
          this.links = []
          this.dataParticles = []

          // åˆ›å»ºç½‘ç»œ
          this.createNetwork()

          // æ·»åŠ äº‹ä»¶ç›‘å¬
          this.setupEventListeners()
        },

        update: function (oldData) {
          // å¦‚æœé…ç½®æ”¹å˜ï¼Œé‡æ–°åˆ›å»ºç½‘ç»œ
          if (
            oldData.nodeCount !== this.data.nodeCount ||
            oldData.topology !== this.data.topology
          ) {
            this.clearNetwork()
            this.createNetwork()
          }
        },

        tick: function (time) {
          // æ›´æ–°åŠ¨ç”»
          this.updateAnimations(time)
        },

        createNetwork: function () {
          const nodeCount = this.data.nodeCount
          const radius = this.data.radius

          // åˆ›å»ºèŠ‚ç‚¹
          for (let i = 0; i < nodeCount; i++) {
            this.createNode(i, radius)
          }

          // åˆ›å»ºè¿æ¥
          this.createLinks()

          // åˆ›å»ºæ•°æ®ç²’å­
          this.createDataParticles()
        },

        createNode: function (index, radius) {
          // è®¡ç®—èŠ‚ç‚¹ä½ç½®
          const angle = (index / this.data.nodeCount) * Math.PI * 2
          const x = Math.cos(angle) * radius
          const z = Math.sin(angle) * radius

          // éšæœºçŠ¶æ€
          const status = Math.random() > 0.8 ? 'warning' : 'healthy'
          const color = status === 'healthy' ? 0x4285f4 : 0xff9800

          // ä½¿ç”¨ Three.js åˆ›å»ºçƒä½“
          const geometry = new THREE.SphereGeometry(0.3, 16, 16)
          const material = new THREE.MeshStandardMaterial({
            color: color,
            metalness: 0.3,
            roughness: 0.4
          })

          const sphere = new THREE.Mesh(geometry, material)
          sphere.position.set(x, 0, z)
          sphere.castShadow = true

          // ä¿å­˜èŠ‚ç‚¹ä¿¡æ¯
          sphere.userData = {
            type: 'node',
            id: index,
            status: status
          }

          // æ·»åŠ åˆ°åœºæ™¯
          this.object3D.add(sphere)
          this.nodes.push(sphere)

          // åˆ›å»ºèŠ‚ç‚¹æ ‡ç­¾
          this.createNodeLabel(sphere, index)

          return sphere
        },

        createNodeLabel: function (node, index) {
          // åˆ›å»ºæ–‡æœ¬æ ‡ç­¾
          const canvas = document.createElement('canvas')
          const context = canvas.getContext('2d')
          canvas.width = 256
          canvas.height = 128

          // ç»˜åˆ¶æ–‡æœ¬
          context.fillStyle = 'rgba(0, 0, 0, 0)'
          context.fillRect(0, 0, canvas.width, canvas.height)

          context.font = 'bold 40px Arial'
          context.fillStyle = '#333333'
          context.textAlign = 'center'
          context.textBaseline = 'middle'
          context.fillText(`N${index + 1}`, canvas.width / 2, canvas.height / 2)

          // åˆ›å»ºçº¹ç†
          const texture = new THREE.CanvasTexture(canvas)
          const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true
          })

          const sprite = new THREE.Sprite(spriteMaterial)
          sprite.scale.set(2, 1, 1)
          sprite.position.y = 0.8
          node.add(sprite)
        },

        createLinks: function () {
          const nodeCount = this.data.nodeCount

          // æ ¹æ®æ‹“æ‰‘ç±»å‹åˆ›å»ºè¿æ¥
          switch (this.data.topology) {
            case 'ring':
              this.createRingLinks()
              break
            case 'dual-ring':
              this.createDualRingLinks()
              break
            case 'mesh':
              this.createMeshLinks()
              break
          }
        },

        createRingLinks: function () {
          for (let i = 0; i < this.nodes.length; i++) {
            const nextIndex = (i + 1) % this.nodes.length
            this.createLink(i, nextIndex)
          }
        },

        createDualRingLinks: function () {
          // ä¸»ç¯
          for (let i = 0; i < this.nodes.length; i++) {
            const nextIndex = (i + 1) % this.nodes.length
            this.createLink(i, nextIndex, 0x4285f4, 0.8)
          }

          // å¤‡ç”¨ç¯
          for (let i = 0; i < this.nodes.length; i++) {
            const nextIndex = (i + 2) % this.nodes.length
            this.createLink(i, nextIndex, 0x9c27b0, 0.4)
          }
        },

        createMeshLinks: function () {
          for (let i = 0; i < this.nodes.length; i++) {
            for (let j = i + 1; j < this.nodes.length; j++) {
              if (Math.random() > 0.6) {
                // 40%çš„è¿æ¥æ¦‚ç‡
                this.createLink(i, j, 0x4285f4, Math.random() * 0.3 + 0.2)
              }
            }
          }
        },

        createLink: function (fromIndex, toIndex, color = 0x4285f4, opacity = 0.7) {
          const fromNode = this.nodes[fromIndex]
          const toNode = this.nodes[toIndex]

          if (!fromNode || !toNode) return

          // åˆ›å»ºæ›²çº¿è·¯å¾„
          const points = []
          const fromPos = fromNode.position.clone()
          const toPos = toNode.position.clone()

          // æ·»åŠ ä¸­é—´æ§åˆ¶ç‚¹ï¼Œä½¿è¿æ¥çº¿å‘ˆå¼§å½¢
          const midPoint = fromPos.clone().lerp(toPos, 0.5)
          midPoint.y += 1

          points.push(fromPos)
          points.push(midPoint)
          points.push(toPos)

          const curve = new THREE.CatmullRomCurve3(points)
          const curvePoints = curve.getPoints(20)

          // åˆ›å»ºè¿æ¥çº¿å‡ ä½•ä½“
          const geometry = new THREE.BufferGeometry().setFromPoints(curvePoints)
          const material = new THREE.LineBasicMaterial({
            color: color,
            transparent: true,
            opacity: opacity,
            linewidth: 2
          })

          const line = new THREE.Line(geometry, material)
          line.userData = {
            type: 'link',
            from: fromIndex,
            to: toIndex
          }

          this.object3D.add(line)
          this.links.push(line)
        },

        createDataParticles: function () {
          for (let i = 0; i < 8; i++) {
            // 8ä¸ªæ•°æ®ç²’å­
            const geometry = new THREE.SphereGeometry(0.1, 8, 8)
            const material = new THREE.MeshBasicMaterial({
              color: 0x00ff00
            })

            const particle = new THREE.Mesh(geometry, material)
            particle.visible = false
            particle.userData = {
              type: 'particle',
              speed: 0.01 + Math.random() * 0.005,
              progress: Math.random(),
              linkIndex: Math.floor(Math.random() * this.links.length)
            }

            this.object3D.add(particle)
            this.dataParticles.push(particle)
          }
        },

        updateAnimations: function (time) {
          const timeInSeconds = time / 1000

          // èŠ‚ç‚¹æµ®åŠ¨åŠ¨ç”»
          this.nodes.forEach((node, index) => {
            const floatHeight = Math.sin(timeInSeconds + index) * 0.2
            node.position.y = floatHeight

            // èŠ‚ç‚¹è‡ªè½¬
            node.rotation.y += 0.01
          })

          // æ•°æ®ç²’å­åŠ¨ç”»
          this.animateDataParticles(timeInSeconds)
        },

        animateDataParticles: function (time) {
          this.dataParticles.forEach(particle => {
            if (particle.userData.linkIndex >= this.links.length) {
              particle.visible = false
              return
            }

            const link = this.links[particle.userData.linkIndex]
            if (!link || !link.geometry.attributes.position) {
              particle.visible = false
              return
            }

            // æ²¿è¿æ¥çº¿ç§»åŠ¨ç²’å­
            particle.userData.progress += particle.userData.speed
            if (particle.userData.progress > 1) {
              particle.userData.progress = 0
              particle.userData.linkIndex = Math.floor(Math.random() * this.links.length)
              return
            }

            // æ ¹æ®æ•°æ®æµæ–¹å‘è°ƒæ•´è¿›åº¦
            let progress = particle.userData.progress
            if (this.data.dataFlow === 'clockwise') {
              progress = 1 - particle.userData.progress
            }

            // è®¡ç®—ç²’å­ä½ç½®
            const positions = link.geometry.attributes.position.array
            const pointCount = positions.length / 3
            const pointIndex = Math.floor(progress * (pointCount - 1))

            if (pointIndex >= 0 && pointIndex < pointCount) {
              const x = positions[pointIndex * 3]
              const y = positions[pointIndex * 3 + 1]
              const z = positions[pointIndex * 3 + 2]

              particle.position.set(x, y, z)
              particle.visible = true
            }
          })
        },

        clearNetwork: function () {
          // ç§»é™¤æ‰€æœ‰èŠ‚ç‚¹
          this.nodes.forEach(node => {
            this.object3D.remove(node)
            node.geometry.dispose()
            node.material.dispose()
          })

          // ç§»é™¤æ‰€æœ‰è¿æ¥
          this.links.forEach(link => {
            this.object3D.remove(link)
            link.geometry.dispose()
            link.material.dispose()
          })

          // ç§»é™¤æ‰€æœ‰ç²’å­
          this.dataParticles.forEach(particle => {
            this.object3D.remove(particle)
            particle.geometry.dispose()
            particle.material.dispose()
          })

          this.nodes = []
          this.links = []
          this.dataParticles = []
        },

        setupEventListeners: function () {
          // ç›‘å¬ A-Frame çš„é¼ æ ‡äº‹ä»¶
          this.el.addEventListener('click', event => {
            const target = event.detail.intersection.object

            if (target.userData && target.userData.type === 'node') {
              this.handleNodeClick(target)
            }
          })
        },

        handleNodeClick: function (node) {
          console.log('ç‚¹å‡»äº†èŠ‚ç‚¹:', node.userData.id)

          // åˆ‡æ¢èŠ‚ç‚¹é¢œè‰²
          if (node.material.color.getHex() === 0x4285f4) {
            node.material.color.setHex(0xff0000)
          } else {
            node.material.color.setHex(0x4285f4)
          }

          // æ›´æ–° UI
          this.updateUI()
        },

        updateUI: function () {
          const healthyNodes = this.nodes.filter(
            node => node.material.color.getHex() === 0x4285f4
          ).length

          document.getElementById(
            'onlineNodes'
          ).textContent = `${healthyNodes}/${this.nodes.length}`

          document.getElementById('linkStatus').textContent = `${Math.round(
            (healthyNodes / this.nodes.length) * 100
          )}%`
        }
      })

      // ç½‘ç»œç®¡ç†å™¨ç»„ä»¶
      AFRAME.registerComponent('network-manager', {
        init: function () {
          this.network = document.getElementById('network-container')

          // è®¾ç½® UI äº‹ä»¶ç›‘å¬
          this.setupUIListeners()
        },

        setupUIListeners: function () {
          // èŠ‚ç‚¹æ•°é‡æ§åˆ¶
          document.getElementById('nodeCount').addEventListener('change', e => {
            this.network.setAttribute('ring-network', 'nodeCount', e.target.value)
          })

          // æ‹“æ‰‘ç»“æ„æ§åˆ¶
          document.getElementById('topology').addEventListener('change', e => {
            this.network.setAttribute('ring-network', 'topology', e.target.value)
          })

          // æ•°æ®æµå‘æ§åˆ¶
          document.getElementById('dataFlow').addEventListener('change', e => {
            this.network.setAttribute('ring-network', 'dataFlow', e.target.value)
          })

          // åˆ·æ–°ç½‘ç»œ
          document.getElementById('refresh').addEventListener('click', () => {
            const nodeCount = document.getElementById('nodeCount').value
            this.network.setAttribute('ring-network', 'nodeCount', nodeCount)
          })

          // æ¨¡æ‹Ÿæ•…éšœ
          document.getElementById('simulateFault').addEventListener('click', () => {
            this.simulateNetworkFault()
          })

          // è¿›å…¥ VR æ¨¡å¼
          document.getElementById('enterVR').addEventListener('click', () => {
            if (AFRAME.utils.device.isVR()) {
              this.enterVRMode()
            } else {
              alert('æ‚¨çš„è®¾å¤‡ä¸æ”¯æŒ VR æ¨¡å¼')
            }
          })
        },

        simulateNetworkFault: function () {
          const network = this.network.components['ring-network']

          if (network && network.nodes.length > 0) {
            // éšæœºé€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹è®¾ç½®ä¸ºæ•…éšœçŠ¶æ€
            const randomIndex = Math.floor(Math.random() * network.nodes.length)
            const node = network.nodes[randomIndex]

            // å°†èŠ‚ç‚¹é¢œè‰²æ”¹ä¸ºçº¢è‰²
            node.material.color.setHex(0xff0000)

            // æ›´æ–° UI
            network.updateUI()
          }
        },

        enterVRMode: function () {
          const scene = document.querySelector('a-scene')

          if (scene.hasAttribute('vr-mode-ui')) {
            scene.setAttribute('vr-mode-ui', 'enabled', true)
          }

          // è¿›å…¥ VR æ¨¡å¼
          if (scene.enterVR) {
            scene.enterVR()
          }
        }
      })

      // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
      document.addEventListener('DOMContentLoaded', () => {
        // è‡ªåŠ¨æ·»åŠ ç½‘ç»œç®¡ç†å™¨ç»„ä»¶åˆ°åœºæ™¯
        const scene = document.querySelector('a-scene')
        scene.setAttribute('network-manager', '')

        console.log('A-Frame + Three.js ç¯ç½‘å¯è§†åŒ–å·²åŠ è½½')
      })
    </script>
  </body>
</html>
