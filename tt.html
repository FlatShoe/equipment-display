<!DOCTYPE html>
<html>
  <head>
    <title>3D Network Topology</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      body {
        background-color: #0a1929;
        margin: 0;
        overflow: hidden;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      }

      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #66b3ff;
        font-size: 16px;
        z-index: 100;
        background: rgba(10, 25, 41, 0.8);
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #2e4b6e;
        max-width: 300px;
      }

      .node-label {
        color: #fff;
        font-size: 12px;
        text-align: center;
        padding: 4px 8px;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 4px;
        border: 1px solid #2e4b6e;
        pointer-events: none;
        user-select: none;
        white-space: nowrap;
      }

      .stats {
        position: absolute;
        bottom: 20px;
        right: 20px;
        color: #66b3ff;
        background: rgba(10, 25, 41, 0.8);
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #2e4b6e;
        min-width: 200px;
      }

      .stat-item {
        margin: 8px 0;
        display: flex;
        justify-content: space-between;
      }

      .stat-value {
        color: #4dabf7;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <h3>3D Network Topology</h3>
      <p>• Use mouse/touch to rotate, zoom and pan</p>
      <p>• Click on nodes to select</p>
      <p>• Press SPACE to add random node</p>
      <p>• Press R to reset view</p>
    </div>

    <div class="stats">
      <div class="stat-item">
        <span>Nodes:</span>
        <span class="stat-value" id="nodeCount">8</span>
      </div>
      <div class="stat-item">
        <span>Connections:</span>
        <span class="stat-value" id="connectionCount">12</span>
      </div>
      <div class="stat-item">
        <span>Selected:</span>
        <span class="stat-value" id="selectedNode">None</span>
      </div>
      <div class="stat-item">
        <span>Traffic:</span>
        <span class="stat-value" id="trafficLevel">Normal</span>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three'
      import {OrbitControls} from 'https://unpkg.com/three@0.164.0/examples/jsm/controls/OrbitControls.js'
      import {
        CSS3DRenderer,
        CSS3DObject
      } from 'https://unpkg.com/three@0.164.0/examples/jsm/renderers/CSS3DRenderer.js'

      let camera, scene, rendererCSS3D, rendererWebGL
      let controls
      let nodes = []
      let connections = []
      let selectedNode = null
      let mouse = new THREE.Vector2()
      let raycaster = new THREE.Raycaster()
      let trafficAnimation = 0

      // Network configuration
      const networkConfig = {
        nodeTypes: {
          router: {color: 0xff6b6b, size: 0.4, name: 'Router'},
          switch: {color: 0x4ecdc4, size: 0.3, name: 'Switch'},
          server: {color: 0x45b7d1, size: 0.35, name: 'Server'},
          client: {color: 0x96ceb4, size: 0.25, name: 'Client'}
        },
        connectionColors: {
          normal: 0x2e4b6e,
          active: 0x4dabf7,
          error: 0xff4757
        }
      }

      init()

      function init() {
        // Create WebGL renderer
        rendererWebGL = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true
        })
        rendererWebGL.setSize(window.innerWidth, window.innerHeight)
        rendererWebGL.setPixelRatio(window.devicePixelRatio)
        rendererWebGL.shadowMap.enabled = true
        rendererWebGL.shadowMap.type = THREE.PCFSoftShadowMap
        rendererWebGL.domElement.style.position = 'absolute'
        document.body.appendChild(rendererWebGL.domElement)

        // Create CSS3D renderer for labels
        rendererCSS3D = new CSS3DRenderer()
        rendererCSS3D.setSize(window.innerWidth, window.innerHeight)
        rendererCSS3D.domElement.style.position = 'absolute'
        rendererCSS3D.domElement.style.pointerEvents = 'none'
        document.body.appendChild(rendererCSS3D.domElement)

        // Setup scene
        scene = new THREE.Scene()
        scene.background = new THREE.Color(0x0a1929)

        // Setup camera
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)
        camera.position.set(15, 10, 15)
        camera.lookAt(0, 0, 0)

        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4)
        scene.add(ambientLight)

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8)
        directionalLight.position.set(10, 20, 5)
        directionalLight.castShadow = true
        directionalLight.shadow.camera.left = -20
        directionalLight.shadow.camera.right = 20
        directionalLight.shadow.camera.top = 20
        directionalLight.shadow.camera.bottom = -20
        scene.add(directionalLight)

        // Add hemisphere light for better ambient
        const hemisphereLight = new THREE.HemisphereLight(0x081b33, 0x1c3b5e, 0.6)
        scene.add(hemisphereLight)

        // Create grid helper
        const gridHelper = new THREE.GridHelper(20, 20, 0x1a3a5a, 0x0f243e)
        gridHelper.position.y = -2
        scene.add(gridHelper)

        // Setup controls
        controls = new OrbitControls(camera, rendererWebGL.domElement)
        controls.enableDamping = true
        controls.dampingFactor = 0.05
        controls.minDistance = 5
        controls.maxDistance = 50

        // Create network topology
        createRingTopology(8, 8)

        // Event listeners
        window.addEventListener('resize', onWindowResize)
        window.addEventListener('mousemove', onMouseMove)
        window.addEventListener('click', onMouseClick)
        window.addEventListener('keydown', onKeyDown)
        rendererWebGL.domElement.addEventListener('click', onCanvasClick, false)

        // Start animation loop
        animate()
      }

      function createRingTopology(nodeCount, radius) {
        // Clear existing nodes and connections
        nodes.forEach(node => {
          scene.remove(node.mesh)
          scene.remove(node.label)
        })
        connections.forEach(conn => scene.remove(conn))
        nodes = []
        connections = []

        // Create nodes in a ring formation
        const angleStep = (Math.PI * 2) / nodeCount
        const nodeTypes = Object.keys(networkConfig.nodeTypes)

        for (let i = 0; i < nodeCount; i++) {
          const angle = angleStep * i
          const x = Math.cos(angle) * radius
          const z = Math.sin(angle) * radius
          const y = Math.sin(i * 0.5) * 2 // Add some vertical variation

          const nodeType = nodeTypes[i % nodeTypes.length]
          const config = networkConfig.nodeTypes[nodeType]

          createNode(x, y, z, `${config.name} ${i + 1}`, nodeType, i)
        }

        // Create connections (ring topology with some extra connections)
        for (let i = 0; i < nodes.length; i++) {
          // Ring connection
          const nextIdx = (i + 1) % nodes.length
          createConnection(nodes[i], nodes[nextIdx])

          // Add some cross connections for a mesh-like appearance
          if (i % 3 === 0) {
            const crossIdx = (i + 3) % nodes.length
            if (crossIdx !== nextIdx && crossIdx !== i) {
              createConnection(nodes[i], nodes[crossIdx])
            }
          }
        }

        updateStats()
      }

      function createNode(x, y, z, name, type, id) {
        const config = networkConfig.nodeTypes[type]

        // Create node geometry
        const geometry = new THREE.SphereGeometry(config.size, 16, 16)
        const material = new THREE.MeshStandardMaterial({
          color: config.color,
          metalness: 0.3,
          roughness: 0.4,
          emissive: config.color,
          emissiveIntensity: 0.1
        })

        const mesh = new THREE.Mesh(geometry, material)
        mesh.position.set(x, y, z)
        mesh.castShadow = true
        mesh.receiveShadow = true
        mesh.userData = {type, name, id, connections: []}
        scene.add(mesh)

        // Create pulsing effect
        const pulseGeometry = new THREE.SphereGeometry(config.size * 1.5, 16, 16)
        const pulseMaterial = new THREE.MeshBasicMaterial({
          color: config.color,
          transparent: true,
          opacity: 0.3,
          side: THREE.DoubleSide
        })
        const pulseMesh = new THREE.Mesh(pulseGeometry, pulseMaterial)
        pulseMesh.position.copy(mesh.position)
        pulseMesh.userData = {pulse: true, speed: 0.5 + Math.random() * 0.3}
        scene.add(pulseMesh)

        // Create CSS3D label
        const labelDiv = document.createElement('div')
        labelDiv.className = 'node-label'
        labelDiv.textContent = name
        labelDiv.style.backgroundColor = `#${config.color.toString(16).padStart(6, '0')}40`

        const label = new CSS3DObject(labelDiv)
        label.position.set(x, y + 0.8, z)
        label.userData = {type, name, id}
        scene.add(label)

        nodes.push({
          mesh,
          pulse: pulseMesh,
          label,
          name,
          type,
          id,
          position: mesh.position.clone()
        })

        return mesh
      }

      function createConnection(node1, node2) {
        const start = node1.mesh.position
        const end = node2.mesh.position

        const direction = new THREE.Vector3().subVectors(end, start)
        const length = direction.length()
        const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5)

        const geometry = new THREE.CylinderGeometry(0.05, 0.05, length, 8)
        geometry.rotateZ(Math.PI / 2)

        const material = new THREE.MeshStandardMaterial({
          color: networkConfig.connectionColors.normal,
          metalness: 0.4,
          roughness: 0.6
        })

        const connection = new THREE.Mesh(geometry, material)
        connection.position.copy(center)
        connection.lookAt(end)
        connection.rotateX(Math.PI / 2)

        connection.userData = {
          node1: node1.id,
          node2: node2.id,
          active: false,
          trafficLevel: 0
        }

        scene.add(connection)
        connections.push(connection)

        // Add to node connections
        node1.connections = node1.connections || []
        node2.connections = node2.connections || []
        node1.connections.push(connection)
        node2.connections.push(connection)
      }

      function selectNode(node) {
        // Deselect previous node
        if (selectedNode) {
          selectedNode.mesh.material.emissive.setHex(
            networkConfig.nodeTypes[selectedNode.type].color
          )
          selectedNode.mesh.material.emissiveIntensity = 0.1
        }

        // Select new node
        selectedNode = node
        selectedNode.mesh.material.emissive.setHex(0xffffff)
        selectedNode.mesh.material.emissiveIntensity = 0.5

        // Highlight connections
        connections.forEach(conn => {
          if (conn.userData.node1 === node.id || conn.userData.node2 === node.id) {
            conn.material.color.setHex(networkConfig.connectionColors.active)
          } else {
            conn.material.color.setHex(networkConfig.connectionColors.normal)
          }
        })

        document.getElementById('selectedNode').textContent = node.name
      }

      function updateStats() {
        document.getElementById('nodeCount').textContent = nodes.length
        document.getElementById('connectionCount').textContent = connections.length

        // Simulate traffic changes
        const trafficLevels = ['Low', 'Normal', 'High']
        const randomTraffic = trafficLevels[Math.floor(Math.random() * trafficLevels.length)]
        document.getElementById('trafficLevel').textContent = randomTraffic
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        rendererWebGL.setSize(window.innerWidth, window.innerHeight)
        rendererCSS3D.setSize(window.innerWidth, window.innerHeight)
      }

      function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1
      }

      function onMouseClick(event) {
        raycaster.setFromCamera(mouse, camera)
        const intersects = raycaster.intersectObjects(nodes.map(n => n.mesh))

        if (intersects.length > 0) {
          const clickedNode = nodes.find(n => n.mesh === intersects[0].object)
          if (clickedNode) {
            selectNode(clickedNode)
          }
        }
      }

      function onCanvasClick(event) {
        event.stopPropagation()
      }

      function onKeyDown(event) {
        switch (event.code) {
          case 'Space':
            // Add random node
            const angle = Math.random() * Math.PI * 2
            const radius = 6 + Math.random() * 4
            const nodeTypes = Object.keys(networkConfig.nodeTypes)
            const type = nodeTypes[Math.floor(Math.random() * nodeTypes.length)]
            const config = networkConfig.nodeTypes[type]

            const newNode = createNode(
              Math.cos(angle) * radius,
              Math.sin(Math.random() * Math.PI) * 2,
              Math.sin(angle) * radius,
              `${config.name} ${nodes.length + 1}`,
              type,
              nodes.length
            )

            // Connect to 1-3 random existing nodes
            const numConnections = 1 + Math.floor(Math.random() * 3)
            for (let i = 0; i < numConnections && i < nodes.length - 1; i++) {
              const targetNode = nodes[Math.floor(Math.random() * (nodes.length - 1))]
              createConnection(nodes[nodes.length - 1], targetNode)
            }

            updateStats()
            break

          case 'KeyR':
            // Reset view
            camera.position.set(15, 10, 15)
            controls.reset()
            break
        }
      }

      function animate() {
        requestAnimationFrame(animate)
        controls.update()

        trafficAnimation += 0.01

        // Animate nodes (pulsing effect)
        nodes.forEach(node => {
          if (node.pulse) {
            const scale = 1 + 0.2 * Math.sin(trafficAnimation * node.pulse.userData.speed)
            node.pulse.scale.setScalar(scale)
            node.pulse.material.opacity =
              0.2 + 0.2 * Math.sin(trafficAnimation * node.pulse.userData.speed)
          }

          // Rotate labels to face camera
          node.label.lookAt(camera.position)
        })

        // Animate traffic on connections
        connections.forEach((conn, index) => {
          if (Math.random() < 0.1) {
            // 10% chance to activate a connection
            conn.userData.active = true
            conn.userData.trafficLevel = 0.5 + Math.random() * 0.5
          }

          if (conn.userData.active) {
            const intensity = 0.5 + 0.5 * Math.sin(trafficAnimation * 3 + index)
            conn.material.emissiveIntensity = intensity * conn.userData.trafficLevel
            conn.material.emissive.setHex(networkConfig.connectionColors.active)

            if (intensity < 0.51) {
              conn.userData.active = false
            }
          } else {
            conn.material.emissiveIntensity = 0
            conn.material.emissive.setHex(0x000000)
          }
        })

        rendererWebGL.render(scene, camera)
        rendererCSS3D.render(scene, camera)
      }
    </script>
  </body>
</html>
